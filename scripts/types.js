require("./validate")
const { parse, TYPE } = require("@formatjs/icu-messageformat-parser")
const { writeFileSync } = require("fs")
const messages = require("../translations/en-GB")

let res = [] // `export = {}`

const parseNode = node => {
  switch (node.type) {
    case TYPE.argument:
      return `${node.value}: string,`
    case TYPE.number:
    case TYPE.plural:
      return `${node.value}: number,`
    case TYPE.date:
    case TYPE.time:
      return `${node.value}: Date | number,`
    case TYPE.select:
      const options = Object.keys(node.options)
      const values = new Set()
      for (const e of options) {
        if (e === "other") {
          // arg can be used inside the `other` clause, let's check for that
          const inner = node.options[e].value.slice()
          flattenAST(inner)
          let types = new Set()
          for (const innerReference of inner.filter(innerNode => innerNode.value === node.value)) {
            switch (innerReference.type) {
              case TYPE.argument:
                types.add("string")
                break
              case TYPE.number:
              case TYPE.plural:
                types.add("number")
                break
              case TYPE.date:
              case TYPE.time:
                types.add("Date | number")
                break
            }
          }
          values.add(Array.from(types).join(" | ") || "string")
        }
        else if (!isNaN(e)) values.add("number")
        else if (e === "null") values.add("null")
        else if ((e === "true" || e === "false") && !values.has("boolean")) {
          values.add(e)
          if (values.has("true") && values.has("false")) {
            values.delete("true")
            values.delete("false")
            values.add("boolean")
          }
        }
        else values.add(`"${e}"`)
      }
      const presets = ["string", "number", "true", "false", "boolean", "null"]
      const value = [...values].sort((a, b) => presets.indexOf(a) - presets.indexOf(b)).join(" | ") || "unknown"
      return `${node.value}: ${value},`
  }
}

const flattenAST = ast => {
  for (const node of ast)
    if (node.type === TYPE.select || node.type === TYPE.plural)
      for (const option of Object.values(node.options))
        for (const child of option.value) {
          const temp = [child]
          flattenAST(temp)
          ast.push(...temp)
        }
}

const iterate = (obj, key = "") => {
  for (const i in obj) {
    const str = Array.isArray(obj[i]) ? obj[i].join("") : obj[i]
    if (typeof str === "object") iterate(str, key + i + ".")
    else if (typeof str === "string" && str.includes("{")) {
      let obj = []
      let keys = []
      let ast
      try {
        ast = parse(str, { ignoreTag: true, requiresOtherClause: false })
      } catch (error) {
        const { location } = error
        console.error(`Invalid translation for ${key}${i}:`)
        if (location.start.line !== location.end.line) throw error
        else {
          let e = new error.constructor(`${error}\n\n${str}\n${" ".repeat(location.start.offset)}${"~".repeat(location.end.offset - location.start.offset)}`)
          throw e
        }
      }
      flattenAST(ast)

      for (const node of ast) {
        if (keys.includes(node.value)) continue
        const field = parseNode(node)
        if (!field) continue
        obj.push(field)
        keys.push(node.value)
      }
      res.push(
        `"${key + i}": {\n    ${obj.join("\n    ")}\n  },`
      )
    }
  }
}
iterate(messages)

writeFileSync("./types.d.ts", `
// auto generated by ./scripts/types.js

declare type MessageParameters = {
  ${res.join("\n  ")}
}

export = MessageParameters
`.trim())
console.log(`Wrote types for ${res.length} translations. (../types.d.ts)`)